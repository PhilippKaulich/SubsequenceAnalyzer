# -*- coding: utf-8 -*-
"""
Created on Thu Oct 20 15:42:28 2022

@author: Philipp

v1.0.2
Changelog
- v1.0.0 first release
- v1.0.1 minor bugfixes
- v1.0.2 include ambiguous subsequence proteoforms (can arise from multiple 
            proteins) if proteins have the same potential cleavage site
- v1.0.3 visualization: added histograms to heatmap 
- v2.0.0 added protein analysis
"""


import pandas as pd
from collections import Counter
import ReadProteoforms
import ReadFastaFile
from MyPlots import create_cleavage_site_plot, truncations_pi_chart, \
    plot_methionin_cleaveage, plot_methionin_cleavaege_absolut
from Settings import Settings
from Tools import check_multiple_lists_are_identical, \
    only_one_unique_element_in_list



class AnalyzeCleavageSites:
    def __init__(self, fasta_file):
        self.ReadFastaFile = ReadFastaFile.ReadFastaFile()
        self.fasta_dict = self.ReadFastaFile.read_fasta_file(fasta_file)

    
		
    def find_subsequence_in_full_sequence(self, subsequence: str, 
                                          full_sequence: str) -> [int, int]:
        """
        Returns position of subsequence which is within annotated sequence

        Parameters
        ----------
        subsequence : str
            Subsequence proteoform sequence.
        full_sequence : str
            Annotated proteoform sequence. 

        Returns
        -------
        [int, int]
            Start and endposition (first amini acid: 0) of subsequence 
            proteoform in relation to annotated proteoform.

        """
        start_pos = full_sequence.find(subsequence)
        end_pos = start_pos + len(subsequence) 
        return start_pos, end_pos
		
		
		
    def check_nterminal_truncation(self, start_pos):
        """ True if N-terminal truncatated """
        return start_pos != 0 and start_pos != 1
    
    
    
    def check_cterminal_truncation(self, full_sequence, end_pos):
        """ True if N-terminal truncatated """
        return end_pos != len(full_sequence)
		
    
    def check_truncations(self, truncations, full_sequence, start_pos, end_pos, 
                          annotated): 
        #truncations = {"N-term": 0, "C-term": 0, "N- and C-term": 0, "Full length": 0}
        n_term_truncation = self.check_nterminal_truncation(start_pos)
        c_term_truncation = self.check_cterminal_truncation(full_sequence, end_pos)
        if annotated:
            truncations[3] += 1
        elif not n_term_truncation and not c_term_truncation:
            truncations[3] += 1
        elif n_term_truncation and c_term_truncation:
            truncations[0] += 1
        elif n_term_truncation and not c_term_truncation:
            truncations[1] += 1
        elif c_term_truncation and not n_term_truncation:
            truncations[2] += 1
        # elif not c_term_truncation and not n_term_truncation:
        #     truncations[3] += 1
        return truncations
    
    
    def _anylaze_methionine_cleavage(self, start_pos, full_sequence):
        # [cleaved, not_cleaved]
        cleaved = False
        not_cleaved = False
        if start_pos == 0:
            not_cleaved = full_sequence[1]
        elif start_pos == 1:
            cleaved = full_sequence[1]
        else:
            pass
        return [cleaved, not_cleaved]
    
    
    def find_cleavage_sites(self, subsequence: str, full_sequence: str) -> [list]:
        """
        Returns cleavage site (X|X') of subsequence within annotated  proteoform.
        If subsequence proteoform is generated by N- and C-terminal truncations, 
        both cleavage sites are returned 

        Parameters
        ----------
        subsequence : str
            Subsequence proteoform sequence.
        full_sequence : str
            Annotated proteoform sequence. 

        Returns
        -------
        list
            Contains potential cleavage sites as [[X|X'], [X|X']]

        """
        start_pos, end_pos = self.find_subsequence_in_full_sequence(subsequence, 
                                                                full_sequence)
        cleav_list = []
        if self.check_cterminal_truncation(full_sequence, end_pos): 
            x = full_sequence[end_pos - 1]
            x_prime = full_sequence[end_pos]
            cleav_list.append([x, x_prime])
        # N-terminal truncated
        if self.check_nterminal_truncation(start_pos):  
            x = full_sequence[start_pos - 1]
            x_prime = full_sequence[start_pos]
            cleav_list.append([x, x_prime])
        return cleav_list



    def _check_multiple_lists_are_identical(self, ll):
        if len(ll) == 0: return True
        h1 = []
        l1 = ll[0]
        for l2 in ll[1:]:
            h1.append(sorted(l1) == sorted(l2))
        return False if False in h1 else True

    

    def _show_progress(self, i, total):
        if i%500 == 0: 
            print ("{} (= {:.0%}) proteoforms processed".format(i, i/total))




    def find_subsequence_termini(self, 
                                 sequences: list, 
                                 prsms: list, 
                                 prosight_subsequence: list = False, 
                                 prosight_annotated: list = False, 
                                 level: str = "proteoform"): 
        """ all proteoforms, that were not identified in annotated proteoform
            search, level = proteoform or prsms ->  
            # Proteoform-Level: Count #Proteoforms, PrSMs-Level: Count #PrSMs """
        number_sequences = len(sequences)
        aa_df = pd.DataFrame(0, columns = Settings.aa_list, index = Settings.aa_list)
        ambigious = 0
        number_considered_subsequence_proteoforms = 0
        # truncations = [N-term, C-term, N- and C-term, Full length]
        truncations = [0, 0, 0, 0]
        # {Accession: [Full_Sequence, [StartPos1, Endpos1, sequence, #prms], ...]}
        accession_proteoforms = {}
        # Methionin cleavaed [[cleaved], [not-cleaved]]
        met_cleav = {Settings.not_cleaved: [], Settings.cleaved: []}
        for index, (sequence, prsm) in enumerate(zip(sequences, prsms)):
            if prosight_subsequence: 
                subsequence = True if prosight_subsequence[index] == "High" else False
            else:
                subsequence = True
            if prosight_annotated: 
                annotated = True if prosight_annotated[index] == "High" else False
            else:
                annotated = False
            self._show_progress(index, number_sequences)
            prots = self.ReadFastaFile.find_sequence(self.fasta_dict, 
                                                     sequence)
            counter_ = 1 if level=="Proteoform Level" else prsm
            if len(prots) > 1: 
                # print("Ambiguous sequence (sequence proteoform can "
                #       "arise from multiple proteins): ", prots, sequence)
                ambigious += 1 
            elif len(prots) == 0: 
                print(sequence, "not found in fasta file")
                continue
            # if multiple proteins, check if all have the same potential cleavage site
            nterm_x_sites, cterm_x_sites = [], []
            nterm_x_prime_sites, cterm_x_prime_sites = [], []
            # if multiple proteins, check if all have the same truncation
            truncations_temp = []
            # check for each protein from which the sequence proteoform 
            # can arise the X|X' position 
            for accession in prots:
                full_sequence = self.ReadFastaFile.find_protein(self.fasta_dict, 
                                                                    accession)
                start_pos, end_pos = self.find_subsequence_in_full_sequence\
                                                    (sequence, full_sequence)
                if accession not in accession_proteoforms: 
                    accession_proteoforms[accession] = [full_sequence, []]
                accession_proteoforms[accession][1].append([start_pos, end_pos,
                                                            sequence, prsm])
                truncations_temp.append(self.check_truncations([0,0,0,0], 
                            full_sequence, start_pos, end_pos, annotated))
                #C-terminal truncation?
                if self.check_cterminal_truncation(full_sequence, end_pos): 
                    x = full_sequence[end_pos - 1]
                    x_prime = full_sequence[end_pos]
                    cterm_x_sites.append(x)
                    cterm_x_prime_sites.append(x_prime)
                else:
                    cterm_x_sites.append(-1)
                    cterm_x_prime_sites.append(-1)
                # N-terminal truncation? 
                if self.check_nterminal_truncation(start_pos):  
                    x = full_sequence[start_pos - 1]
                    x_prime = full_sequence[start_pos]
                    nterm_x_sites.append(x)
                    nterm_x_prime_sites.append(x_prime)
                else:
                    nterm_x_sites.append(-1)
                    nterm_x_prime_sites.append(-1)
            # consider X|X' if X|X' for all possible proteins is equal anf if prosight subsequence
            if only_one_unique_element_in_list(cterm_x_prime_sites) and subsequence and cterm_x_prime_sites[0] != -1: 
                    aa_df[cterm_x_sites[0]][cterm_x_prime_sites[0]] += counter_
            if only_one_unique_element_in_list(nterm_x_sites) and subsequence and nterm_x_sites[0] != -1: 
                    aa_df[nterm_x_sites[0]][nterm_x_prime_sites[0]] += counter_
            if (only_one_unique_element_in_list(nterm_x_sites) and nterm_x_sites[0] != -1) or \
                (only_one_unique_element_in_list(cterm_x_prime_sites) and cterm_x_sites[0] != -1) and subsequence:
                    number_considered_subsequence_proteoforms += 1
            # consider truncation only if for all possible proteins the same
            if check_multiple_lists_are_identical(truncations_temp):
                truncations = [i + j for i, j in zip(truncations, truncations_temp[0])]
                # Methionine-cleavage 
                cleaved, not_cleaved = self._anylaze_methionine_cleavage(start_pos, 
                                                                    full_sequence)
                if cleaved: met_cleav[Settings.cleaved].append(cleaved) 
                if not_cleaved: met_cleav[Settings.not_cleaved].append(not_cleaved)
        aa_df = aa_df.T
        aa_df = aa_df.sort_index(ascending=False)
        accession_proteoforms_new = dict(accession_proteoforms)
        for acc in accession_proteoforms:
            number_proteoforms = len(accession_proteoforms[acc][1])
            if number_proteoforms < 5:
                del accession_proteoforms_new[acc]
        print("Considered Proteoforms", number_considered_subsequence_proteoforms)
        print("Total potential cleavage events: {}".format(aa_df.sum().sum()))
        return(aa_df, accession_proteoforms_new, truncations, met_cleav)
    

    
    
    def analyze_aa_content_in_database(self):
        """ """
        sequences  = list(self.fasta_dict.values())
        df = pd.DataFrame(0, columns=Settings.aa_list, index=Settings.aa_list)
        aa_dict = {}
        for aa in Settings.aa_list:
            aa_dict[aa] = {}
            for aa2 in list(reversed(Settings.aa_list)):
                aa_dict[aa][aa2] = 0
        for sequence in sequences:
            for index, aa in enumerate(sequence[0:-1]):
                aa_1 = sequence[index]
                aa_2 = sequence[index + 1]
                aa_dict[aa_2][aa_1] += 1
        df = pd.DataFrame(aa_dict)
        print(df.to_string())
        create_cleavage_site_plot(df)
        return df
    
    
    def save_data(self, df, file_name):
        df.to_csv(file_name)
        print(file_name, "successfully saved")
            
        
# if __name__ == '__main__':
#     fasta = "Dataset\\Uniprot_83333_Ecoli_FASTA_all.fasta"
#     a = AnalyzeCleavageSites(fasta)
#     df = a.analyze_aa_content_in_database()
    # r = ReadProteoforms.ReadProteoforms(pd_version="v4.0")
    # df = r.read_prosight_results("Dataset\\DEMO_Proteoforms.txt")
    # aa_df = a.find_subsequence_termini(df["Sequence"], df["# PrSMs"], level="Proteoform Level")







    
        
# ######################
#     def analyze_proteoforms(self, sequences, prsms):
#         number_processed_proteoforms = 0
#         accession_proteoforms = {}
#         for sequence, prsm in zip(sequences, prsms):
#             number_processed_proteoforms += 1
#             if number_processed_proteoforms%500 == 0: 
#                 print (number_processed_proteoforms, "processed")
#             prots = self.ReadFastaFile.find_sequence(self.fasta_dict, 
#                                                      sequence)
#             if len(prots) == 0: print(sequence, "not found in fasta file")
#             for accession in prots:
#                 full_sequence = self.ReadFastaFile.find_protein(self.fasta_dict, 
#                                                                     accession)
#                 start_pos, end_pos = self.find_subsequence_in_full_sequence\
#                                                     (sequence, full_sequence)
#                 if accession not in accession_proteoforms: 
#                     accession_proteoforms[accession] = [full_sequence, []]
#                 accession_proteoforms[accession][1].append([start_pos, end_pos, sequence, prsm])
#         accession_proteoforms_new = dict(accession_proteoforms)
#         for acc in accession_proteoforms:
#             number_proteoforms = len(accession_proteoforms[acc][1])
#             if number_proteoforms < 5:
#                 del accession_proteoforms_new[acc]
#             else:
#                 print(acc, number_proteoforms)
#         return accession_proteoforms_new
# ##################



            
    # def analyze_met_cleavage(self, d):
    #     #d = {"notcleaved": [], "cleaved": []}
    #     absolut_cleaved_sum = {}
    #     notcleaved = Counter(d[Settings.not_cleaved])
    #     print("Number of not-cleaved Start-Methionins", len(d[Settings.not_cleaved]))
    #     cleaved = Counter(d[Settings.cleaved])
    #     print("Number of cleaved Start-Methionins", len(d[Settings.cleaved]))
    #     ration_cleaved_sum = {}
    #     print("AA\tCleaved\tNot-Cleaved")
    #     for aa in Settings.aa_list:
    #         if aa not in notcleaved and aa not in cleaved: continue
    #         if aa not in notcleaved: notcleaved[aa] = 0
    #         if aa not in cleaved: cleaved[aa] = 0
    #         absolut_cleaved_sum[aa] = [cleaved[aa], notcleaved[aa]]
    #         print(aa, cleaved[aa], "\t", notcleaved[aa])
    #         ration_cleaved_sum[aa] = cleaved[aa] / (cleaved[aa] + notcleaved[aa])
    #     return absolut_cleaved_sum, ration_cleaved_sum
